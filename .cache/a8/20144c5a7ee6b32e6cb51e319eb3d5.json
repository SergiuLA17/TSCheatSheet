{"id":"../category/fundamental.html","dependencies":[{"name":"./../js/script.js","dynamic":true,"resolved":"/Users/segio/WebstormProjects/TSCheatSheet/js/script.js","parent":"/Users/segio/WebstormProjects/TSCheatSheet/category/fundamental.html"},{"name":"./../js/button.js","dynamic":true,"resolved":"/Users/segio/WebstormProjects/TSCheatSheet/js/button.js","parent":"/Users/segio/WebstormProjects/TSCheatSheet/category/fundamental.html"},{"name":"./../css/content.css","dynamic":true,"resolved":"/Users/segio/WebstormProjects/TSCheatSheet/css/content.css","parent":"/Users/segio/WebstormProjects/TSCheatSheet/category/fundamental.html"},{"name":"./../css/button.css","dynamic":true,"resolved":"/Users/segio/WebstormProjects/TSCheatSheet/css/button.css","parent":"/Users/segio/WebstormProjects/TSCheatSheet/category/fundamental.html"},{"name":"./../index.html","dynamic":true,"resolved":"/Users/segio/WebstormProjects/TSCheatSheet/index.html","entry":true,"parent":"/Users/segio/WebstormProjects/TSCheatSheet/category/fundamental.html"},{"name":"/Users/segio/package.json","includedInParent":true,"mtime":1677167980474}],"generated":{"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n\n    <meta content=\"IE=edge\" http-equiv=\"X-UA-Compatible\">\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\">\n    <link href=\"/4d585f9387deb4b55fb2e184f5aa2ae4.js\" rel=\"stylesheet\">\n    <link href=\"/c06b307f38f8a2264d6125c5447dd70b.js\" rel=\"stylesheet\">\n    <link href=\"/8519916c728143e15d4c451740c45981.css\" rel=\"stylesheet\">\n    <link href=\"/feab1f06663f8786104d484232f74777.css\" rel=\"stylesheet\">\n    <link href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css\" rel=\"stylesheet\">\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js\"></script>\n    <script>hljs.highlightAll();</script>\n\n    <script src=\"//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>\n\n    <title>Document</title>\n\n</head>\n<body>\n\n<div id=\"rendered-js\">\n    <a class=\"btn-flip\" data-back=\"Back\" data-front=\"Back\" href=\"/aeb838fd801aabb6b0904e22562b7d65.html\"></a>\n    <div class=\"accordionWrapper\">\n        <!--Parcel-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Parcel</h2>\n            <div class=\"accordionItemContent\">\n                <pre class=\"codeStyle\">\n                    <code>\n// parcel este un bundler de module, care face mai usor procesul de dezvoltare a aplicatiilor web.\n// parcel are un server de dezvoltare integrat, care face refresh la pagina web la fiecare modificare a codului.\n// pentru a rula un server de dezvoltare, trebuie sa rulam comanda: parcel index.html\n// pentru a instala parcel, trebuie sa rulam comanda: npm install -g parcel-bundler\n\n                  </code>\n                </pre>\n\n            </div>\n        </div>\n        <!--Syntax-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Syntax</h2>\n            <div class=\"accordionItemContent\">\n                <pre class=\"codeStyle\">\n                    <code>\n//varaibilele in typescript se declara cu let sau const, nu cu var, deoarece var este globala si poate fi folosita oriunde in cod.\n//dar let si const sunt locale si pot fi folosite doar in functia in care au fost declarate.\nlet apples: number;\napples = 5;\n\nlet speed: string = 'fast';\nlet hasName: boolean = true;\n\nlet nothingMuch: null = null;\nlet nothing: undefined = undefined;\n\n// Built in objects\nlet now: Date = new Date();\n\n// Array\nlet colors: string[] = ['red', 'green', 'blue'];\nlet myNumbers: number[] = [1, 2, 3];\nlet truths: boolean[] = [true, false, true];\n\n// Classes\nclass Car {\n\n}\nlet car: Car = new Car();\n\n// Object literal\nlet point: { x: number; y: number } = {\n    x: 10,\n    y: 20\n}\n\n// Function\nconst logNumber: (i: number) => void = (i: number) => {\n    console.log(i);\n}\n\n                  </code>\n                </pre>\n\n            </div>\n        </div>\n        <!--TypeAnnotations-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Type annotations</h2>\n            <div class=\"accordionItemContent\">\n                <pre>\nEste o modalitate de a specifica tipul unei variabile, functii, clase, etc. Folosim atunci cand dorim sa clarificam ce tip de variabila se va returna.\nExemplu de cazuri unde trebuie de folosit pentru variabile:\n                    <code>\n/*\n1)Cand tipul de returnare este any.\nAdica typescript nu stie ce fel de tip se returneaza si in acest cat ts nu ne poate ajuta sa identificam erorile.\n*/\nconst json1 = '{\"x\": 10, \"y\": 20}';\nconst obj1  = JSON.parse(json);\n//in cazul dat ts nu stie despre tipul de date, si in caz cand vrem sa lucram cu variabila, nu o sa se poata\n//sa ne reprezinte metodele specifice tipului de date.\n\n//Astfel se adauga tipul de date, si astfel TS va intelege cu ce tip de date lucram.\n\nconst json = '{\"x\": 10, \"y\": 20}';\nconst obj: number = JSON.parse(json);\nconst coords: { x: number; y: number } = JSON.parse(json);\n\n/* 2)Atunci cand declaram o variabila pe o linie si o initializam pe alta linie. */\nlet words = ['red', 'green', 'blue'];\nlet foundWord: boolean;\n\nfor (let i = 0; i < words.length; i++) {\n    if(words[i] === 'green') {\n        foundWord = true;\n    }\n}\n/* 3)Variabila care are un tip de date, dar ulterior primeste aslt tip de date. */\nlet numberAboveZero = false;\n\nfor (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > 0) {\n        numberAboveZero = numbers[i];\n    }\n}\n//In cazul dat, in consola va aparea eroare, deoarece numberAboveZero este de tipul boolean, iar noi dorim\n//sa-i atribuim un numar. In JS asa cod va lucra, dar in TS nu, si astfel trebuie sa specificam tipul de date\nlet numbers = [-10, -1, 12];\nlet numberAboveZero: boolean | number = false;\n\nfor (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > 0) {\n        numberAboveZero = numbers[i];\n    }\n}\n                </code></pre>\nPentru Functii\n                <pre><code>\n\n //in cazul dat in paranteza se scrie argumentii, iar alaturi tipul de date care se vor returna.\n const add = (a: number, b: number): boolean => {\n    return true;\n}\n//inca o syntaxa\nfunction divide(a: number, b: number): number {\n    return a / b;\n}\n//inca o syntaxa\nconst multiply = function (a: number, b: number): number {\n    return a * b;\n}\n//se anoteaza cu void in caz ca nu returneaza nimic, dar de fapt putem returna undefined sau null\nconst logger = (message: string): void => {\n    console.log(message);\n}\n//se anoteaza cu never in caz ca nu returneaza nimic si nu se poate ajunge la finalul functiei\nconst throwError = (message: string): never => {\n    throw new Error(message);\n}\n                </code></pre>\nPentru Obiecte\n                <pre><code>\n 1)Destructuring\n //syntax destructuring inseamnta ca vom extrage date si weather din obiectul forecast si vom crea 2 variabile date si weather si le vom anota cu tipul Date si string\nconst forecast = {\n    date: new Date(),\n    weather: 'sunny'\n}\nconst logWeather = ({date, weather}: { date: Date, weather: string }): void => {\n    console.log(date)\n    console.log(weather)\n}\nlogWeather(forecast);\n\n2)Destructuring cu obiecte in obiecte\nconst profile = {\n    name: 'alex',\n    age: 20,\n    coords: {\n        lat: 0,\n        lng: 15\n    },\n    setAge(age: number): void {\n        this.age = age;\n    }\n}\n//in cazul dat extragem din obiectul profile doar age si anotam variabila age cu tipul number\nconst { age }: { age: number } = profile;\n//in cazul dat extragem din obiectul profile doar coords si anotam variabila coords cu tipul { lat: number; lng: number }\nconst { coords: { lat, lng } }: { coords: { lat: number; lng: number } } = profile;\n\nconsole.log(age);\nconsole.log(lat);\nconsole.log(lng);\n                </code></pre>\n            </div>\n        </div>\n        <!--TypeInterface-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Type interface</h2>\n            <div class=\"accordionItemContent\">\n                Prin type interface typescriptul singur va afla tipul de date al unei variabile initializate.\n                Lucreaza numai atunci cand declararea si initializarea se face intr-o linie.\n\n            </div>\n        </div>\n        <!--Interfaces-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Interfaces</h2>\n            <div class=\"accordionItemContent\">\n                <pre class=\"codeStyle\"><code>\n//in codul de mai jos, am folosit o functie care primeste ca parametru un obiect, dar argumentele sunt destul de multe\n// si in cazul dat putem crea mai bine o interfata\nconst printVehicle = (vehicle: { name: string; year: number; broken: boolean }): void => {\n    console.log(`Name: ${vehicle.name}`);\n    console.log(`Year: ${vehicle.year}`);\n    console.log(`Broken: ${vehicle.broken}`);\n}\n\nprintVehicle(oldCivic);\n\ninterface Vehicle {\n    name: string;\n    year: number;\n    broken: boolean\n}\n\n//dupa aceasta doar introducem dupa parametrul vehicle, interfata Vehicle\nconst printVehicleFix = (vehicle: Vehicle): void => {\n    console.log(`Name: ${vehicle.name}`);\n    console.log(`Year: ${vehicle.year}`);\n    console.log(`Broken: ${vehicle.broken}`);\n}\n\n//in general interfata creaza un nou tip, care poate fi folosit in orice parte a codului\n                    </code></pre>\n<pre class=\"codeStyle\"><code>\n//codul de mai jos reprezinta un cod mai general avem o interfata care raporteaza un obiect si avem o functie care primeste\n// ca parametru un obiect care implementeaza interfata Reportable\ninterface Reportable {\n    summary(): string;\n}\nconst oldCivic = {\n    name: 'civic',\n    year: 2000,\n    broken: true,\n    summary(): string {\n        return `Name: ${this.name}, Year: ${this.year}, Broken: ${this.broken}`;\n    }\n}\nconst printSummary = (item: Reportable): void => {\n    console.log(item.summary());\n}\n\nprintSummary(oldCivic);\n                </code></pre>\n            </div>\n        </div>\n        <!--Export-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Export</h2>\n            <div class=\"accordionItemContent\">\n                <pre class=\"codeStyle\"><code>\n//cuvantul \"export\" permite sa folosim o functie sau o clasa in alt fisier\n//sintaxa pentru import este\nimport { functia } from './fisierul'\n//dacaavem mai multe functii sau obiecte cu export, le vom importa in felul urmator, denumirile se adauga in acolade\nimport { functia, functia2 } from './fisierul'\n//daca avem export defoult, atunci importul se face\nimport functia from './fisierul'\n\nexemplu\nin fisieul1.ts declaram\n\nexport default 'red';\n\napoi vrem sa importam in fisierul2.ts\n\nimport culoare from './fisierul1'\nconsole.log(culoare); // se va afisa red\n                                    </code></pre>\n\n            </div>\n        </div>\n        <!--Template-->\n        <div class=\"accordionItem close\">\n            <h2 class=\"accordionItemHeading \">Arrays</h2>\n            <div class=\"accordionItemContent\">\n                Prin type interface typescriptul singur va afla tipul de date al unei variabile initializate.\n                Lucreaza numai atunci cand declararea si initializarea se face intr-o linie.\n\n            </div>\n        </div>\n    </div>\n</div>\n<script src=\"/4d585f9387deb4b55fb2e184f5aa2ae4.js\">\n</script>\n\n</body>\n</html>\n"},"sourceMaps":null,"error":null,"hash":"c64e642ef7d0c02959bf03acd1615cfb","cacheData":{"env":{}}}