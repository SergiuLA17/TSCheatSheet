<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <link href="/script.f5aa2ae4.js" rel="stylesheet">
    <link href="/button.447dd70b.js" rel="stylesheet">
    <link href="/content.40c45981.css" rel="stylesheet">
    <link href="/button.32f74777.css" rel="stylesheet">
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css" rel="stylesheet">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

    <title>Document</title>

</head>
<body>

<div id="rendered-js">
    <a class="btn-flip" data-back="Back" data-front="Back" href="/__/index.html"></a>
    <div class="accordionWrapper">
        <!--Parcel-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Parcel</h2>
            <div class="accordionItemContent">
                <pre class="codeStyle">
                    <code>
// parcel este un bundler de module, care face mai usor procesul de dezvoltare a aplicatiilor web.
// parcel are un server de dezvoltare integrat, care face refresh la pagina web la fiecare modificare a codului.
// pentru a rula un server de dezvoltare, trebuie sa rulam comanda: parcel index.html
// pentru a instala parcel, trebuie sa rulam comanda: npm install -g parcel-bundler

                  </code>
                </pre>

            </div>
        </div>
        <!--Syntax-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Syntax</h2>
            <div class="accordionItemContent">
                <pre class="codeStyle">
                    <code>
//varaibilele in typescript se declara cu let sau const, nu cu var, deoarece var este globala si poate fi folosita oriunde in cod.
//dar let si const sunt locale si pot fi folosite doar in functia in care au fost declarate.
let apples: number;
apples = 5;

let speed: string = 'fast';
let hasName: boolean = true;

let nothingMuch: null = null;
let nothing: undefined = undefined;

// Built in objects
let now: Date = new Date();

// Array
let colors: string[] = ['red', 'green', 'blue'];
let myNumbers: number[] = [1, 2, 3];
let truths: boolean[] = [true, false, true];

// Classes
class Car {

}
let car: Car = new Car();

// Object literal
let point: { x: number; y: number } = {
    x: 10,
    y: 20
}

// Function
const logNumber: (i: number) => void = (i: number) => {
    console.log(i);
}

                  </code>
                </pre>

            </div>
        </div>
        <!--TypeAnnotations-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Type annotations</h2>
            <div class="accordionItemContent">
                <pre>
Este o modalitate de a specifica tipul unei variabile, functii, clase, etc. Folosim atunci cand dorim sa clarificam ce tip de variabila se va returna.
Exemplu de cazuri unde trebuie de folosit pentru variabile:
                    <code>
/*
1)Cand tipul de returnare este any.
Adica typescript nu stie ce fel de tip se returneaza si in acest cat ts nu ne poate ajuta sa identificam erorile.
*/
const json1 = '{"x": 10, "y": 20}';
const obj1  = JSON.parse(json);
//in cazul dat ts nu stie despre tipul de date, si in caz cand vrem sa lucram cu variabila, nu o sa se poata
//sa ne reprezinte metodele specifice tipului de date.

//Astfel se adauga tipul de date, si astfel TS va intelege cu ce tip de date lucram.

const json = '{"x": 10, "y": 20}';
const obj: number = JSON.parse(json);
const coords: { x: number; y: number } = JSON.parse(json);

/* 2)Atunci cand declaram o variabila pe o linie si o initializam pe alta linie. */
let words = ['red', 'green', 'blue'];
let foundWord: boolean;

for (let i = 0; i < words.length; i++) {
    if(words[i] === 'green') {
        foundWord = true;
    }
}
/* 3)Variabila care are un tip de date, dar ulterior primeste aslt tip de date. */
let numberAboveZero = false;

for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
        numberAboveZero = numbers[i];
    }
}
//In cazul dat, in consola va aparea eroare, deoarece numberAboveZero este de tipul boolean, iar noi dorim
//sa-i atribuim un numar. In JS asa cod va lucra, dar in TS nu, si astfel trebuie sa specificam tipul de date
let numbers = [-10, -1, 12];
let numberAboveZero: boolean | number = false;

for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
        numberAboveZero = numbers[i];
    }
}
                </code></pre>
Pentru Functii
                <pre><code>

 //in cazul dat in paranteza se scrie argumentii, iar alaturi tipul de date care se vor returna.
 const add = (a: number, b: number): boolean => {
    return true;
}
//inca o syntaxa
function divide(a: number, b: number): number {
    return a / b;
}
//inca o syntaxa
const multiply = function (a: number, b: number): number {
    return a * b;
}
//se anoteaza cu void in caz ca nu returneaza nimic, dar de fapt putem returna undefined sau null
const logger = (message: string): void => {
    console.log(message);
}
//se anoteaza cu never in caz ca nu returneaza nimic si nu se poate ajunge la finalul functiei
const throwError = (message: string): never => {
    throw new Error(message);
}
                </code></pre>
Pentru Obiecte
                <pre><code>
 1)Destructuring
 //syntax destructuring inseamnta ca vom extrage date si weather din obiectul forecast si vom crea 2 variabile date si weather si le vom anota cu tipul Date si string
const forecast = {
    date: new Date(),
    weather: 'sunny'
}
const logWeather = ({date, weather}: { date: Date, weather: string }): void => {
    console.log(date)
    console.log(weather)
}
logWeather(forecast);

2)Destructuring cu obiecte in obiecte
const profile = {
    name: 'alex',
    age: 20,
    coords: {
        lat: 0,
        lng: 15
    },
    setAge(age: number): void {
        this.age = age;
    }
}
//in cazul dat extragem din obiectul profile doar age si anotam variabila age cu tipul number
const { age }: { age: number } = profile;
//in cazul dat extragem din obiectul profile doar coords si anotam variabila coords cu tipul { lat: number; lng: number }
const { coords: { lat, lng } }: { coords: { lat: number; lng: number } } = profile;

console.log(age);
console.log(lat);
console.log(lng);
                </code></pre>
            </div>
        </div>
        <!--TypeInterface-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Type interface</h2>
            <div class="accordionItemContent">
                Prin type interface typescriptul singur va afla tipul de date al unei variabile initializate.
                Lucreaza numai atunci cand declararea si initializarea se face intr-o linie.

            </div>
        </div>
        <!--Interfaces-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Interfaces</h2>
            <div class="accordionItemContent">
                <pre class="codeStyle"><code>
//in codul de mai jos, am folosit o functie care primeste ca parametru un obiect, dar argumentele sunt destul de multe
// si in cazul dat putem crea mai bine o interfata
const printVehicle = (vehicle: { name: string; year: number; broken: boolean }): void => {
    console.log(`Name: ${vehicle.name}`);
    console.log(`Year: ${vehicle.year}`);
    console.log(`Broken: ${vehicle.broken}`);
}

printVehicle(oldCivic);

interface Vehicle {
    name: string;
    year: number;
    broken: boolean
}

//dupa aceasta doar introducem dupa parametrul vehicle, interfata Vehicle
const printVehicleFix = (vehicle: Vehicle): void => {
    console.log(`Name: ${vehicle.name}`);
    console.log(`Year: ${vehicle.year}`);
    console.log(`Broken: ${vehicle.broken}`);
}

//in general interfata creaza un nou tip, care poate fi folosit in orice parte a codului
                    </code></pre>
<pre class="codeStyle"><code>
//codul de mai jos reprezinta un cod mai general avem o interfata care raporteaza un obiect si avem o functie care primeste
// ca parametru un obiect care implementeaza interfata Reportable
interface Reportable {
    summary(): string;
}
const oldCivic = {
    name: 'civic',
    year: 2000,
    broken: true,
    summary(): string {
        return `Name: ${this.name}, Year: ${this.year}, Broken: ${this.broken}`;
    }
}
const printSummary = (item: Reportable): void => {
    console.log(item.summary());
}

printSummary(oldCivic);
                </code></pre>
            </div>
        </div>
        <!--Export-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Export</h2>
            <div class="accordionItemContent">
                <pre class="codeStyle"><code>
//cuvantul "export" permite sa folosim o functie sau o clasa in alt fisier
//sintaxa pentru import este
import { functia } from './fisierul'
//dacaavem mai multe functii sau obiecte cu export, le vom importa in felul urmator, denumirile se adauga in acolade
import { functia, functia2 } from './fisierul'
//daca avem export defoult, atunci importul se face
import functia from './fisierul'

exemplu
in fisieul1.ts declaram

export default 'red';

apoi vrem sa importam in fisierul2.ts

import culoare from './fisierul1'
console.log(culoare); // se va afisa red
                                    </code></pre>

            </div>
        </div>
        <!--Template-->
        <div class="accordionItem close">
            <h2 class="accordionItemHeading ">Arrays</h2>
            <div class="accordionItemContent">
                Prin type interface typescriptul singur va afla tipul de date al unei variabile initializate.
                Lucreaza numai atunci cand declararea si initializarea se face intr-o linie.

            </div>
        </div>
    </div>
</div>
<script src="/script.f5aa2ae4.js">
</script>

</body>
</html>
